#!/usr/bin/python

import sys
import subprocess
import os
import logging

shortHelpMsg = {}
logging.basicConfig(level=logging.INFO)

# dispatch to subcommand

def doMain():
   logging.info('ProPPR v2')
   opts = {'dryRun':False, 'out':getOutputDirectory()}
   com = getArg(0)
   while True:
      #parse special options -n, -Cfoo
      if com == "-n":
         opts['dryRun'] = True
         sys.argv = sys.argv[1:]
         com = getArg(0)
      elif com.startswith("-C"):
         opts['out']=com[2:]
         if not opts['out'].endswith("/"): opts['out'] += "/"
         sys.argv = sys.argv[1:]
         com = getArg(0)
      else: break
   if com == "help":
      doHelp(opts)
   elif com == "set":
      doSet(opts)
   elif com == "settings":
      doSettings(opts)
   elif com == "compile":
      doCompile(opts)
   elif com == "answer":
      doAnswer(opts)
   elif com == "ground":
      doGround(opts)
   elif com == "show":
      doShow(opts)
   elif com == "eval":
      doEval(opts)
   elif com == "train":
      doTrain(opts)
   elif com == "gradient":
      doGradient(opts)
   elif com.startswith("sg-"):
      doSGSubcommand(opts,com[len("sg-"):])
   else:
      doHelp(opts)
      
# subcommands

def doSet(o):
   opts = loadOptionDict(o)  #also load command-line options
   saveOptionDict(opts,o)
shortHelpMsg['set'] = ' OPTION VALUE: store a default setting in proppr.settings, where OPTION starts with --'

def doSettings(o):
   for key,val in loadOptionDict(o).items():
      print key,val
shortHelpMsg['settings'] = ': show current default settings in proppr.settings'

def doAnswer(o):
   stem,examples = stemExt(getArg(1),'.examples')
   solutions = makeOutput(getArg(2,stem+'.solutions.txt'),o)
   v = getArgvOptions()
   for i in range(len(v)):
      if v[i] == '--params':
         setArgvOption(i+1,getFile(v[i+1],o))
         break
   invokeMain(o,'QueryAnswerer','--queries',examples,'--solutions',solutions)
   logging.info('answers in '+solutions)
shortHelpMsg['answer'] = ' INPUT.examples [OUTPUT.solutions.txt]: answer queries from file and write solutions'

def doGround(o):
   stem,examples = stemExt(getArg(1),'.examples')
   grounded = makeOutput(getArg(2,stem+'.grounded'),o)
   invokeMain(o,'Grounder','--queries',examples,'--grounded',grounded)
   logging.info('grounded to '+grounded)
shortHelpMsg['ground'] = ' INPUT.examples [OUTPUT.grounded]: answer queries from file and write graphs'

def doShow(o):
   stem,grounded = stemExt(getArg(1),'.grounded')
   eid = getArg(2,'1')
   v = getArgvOptions() or ['--maxDepth','-1']
   invokeHelper(o,'show.py',grounded,eid,v[0],v[1])
shortHelpMsg['show'] = ' INPUT.grounded [example#] [--maxDepth d]: display an ASCII representation of a grounded example'

def doEval(o):
   stem,examples = stemExt(getArg(1),'.examples')
   solutions = getFile(getArg(2, stem+'.solutions.txt'),o)
   opts = getArgvOptions() or ['--metric','map']
   root = getRoot()
   callProcess(o,['python',root+'/scripts/answermetrics.py','--data',examples,'--answers',solutions] + opts)
shortHelpMsg['eval'] = ' INPUT.examples INPUT.solutions.txt [--metric mrr|recall|ap] [--echo]: evaluate proposed solutions' 

def doCompile(o):
   stem,src = stemExt(getArg(1),'.ppr')
   dst = getArg(2,stem+".wam")
   root = getRoot()
   callProcess(o,['python',root+'/src/scripts/compiler.py','serialize',src],stdout=open(dst,'w'))
   logging.info('compiled '+ src + ' to ' + dst)
shortHelpMsg['compile'] = ' INPUT.ppr [OUTPUT.wam]: compile a ProPPR program to abstract machine'

def doTrain(o):
   stem,src = stemExt(getArg(1),'.grounded')
   src = getFile(src,o)
   dst = makeOutput(getArg(2,stem+'.params'),o)
   invokeMain(o,'Trainer','--train',src,'--params',dst)
shortHelpMsg['train'] = ' INPUT.examples.grounded [OUTPUT.params]: learn parameters for the prover'

def doGradient(o):
   stem,src = stemExt(getArg(1),'.grounded')
   src = getFile(src,o)
   dst = makeOutput(getArg(2,stem+'.gradient'),o)
   invokeMain(o,'GradientFinder','--grounded',src,'--gradient',dst)
   logging.info('gradient in '+dst)
shortHelpMsg['gradient'] = ' INPUT.examples.grounded [OUTPUT.gradient]: measure gradient with respect to parameters'

def doSGSubcommand(o,subcommand):
   if subcommand in ['lift','lower']:
      stem,src = stemExt(getArg(1),'.cfacts')
      src = getFile(src,o)
      dst = makeOutput(getArg(2),o)
      #no default stem+extension here so we need to add .cfacts extension if it's missing
      if not dst.endswith(".cfacts"): dst = dst+".cfacts"
      invokeHelper(o,'structured-gradient.py',subcommand,src,dst)
   elif subcommand=="rel2ex":
      stem,src = stemExt(getArg(1),'.cfacts')
      src = getFile(src,o)
      dst = makeOutput(getArg(2,stem+'.examples'),o)
      if not dst.endswith(".examples"): dst = dst+".examples"
      invokeHelper(o,'structured-gradient.py',subcommand,src,dst,*getArgvOptions())
   elif subcommand=="grad2ppr":
      stem,src = stemExt(getArg(1),'.cfacts')
      src = getFile(src,o)
      dst = makeOutput(getArg(2,stem+'.ppr'),o)
      invokeHelper(o,'structured-gradient.py',subcommand,src,dst,*getArgvOptions())
   elif subcommand=="train":
      exampleStem,exampleFile = stemExt(getArg(1),'.examples')
      exampleFile = getFile(exampleFile,o)
      backgroundStem,backgroundFile = stemExt(getArg(2),'.cfacts')
      backgroundFile = getFile(backgroundFile,o)
      interpFile = getResourceFile(o, "sg-interp.ppr", "sg-interp-n00.ppr")
      invokeMyself(o,'compile','sg-interp-n00.ppr')
      opts = loadOptionDict(o)
      opts['--programFiles'] = 'sg-interp-n00.wam:'+backgroundFile
      saveOptionDict(opts,o)
      invokeMyself(o,'ground',exampleFile,exampleFile+".grounded")
      invokeMyself(o,'gradient',exampleFile+".grounded",exampleStem+".gradient",'--epochs','0')

shortHelpMsg['sg-lift'] = ' INPUT.cfacts OUTPUT.cfacts: convert arity-two facts to the 2nd-order format used for structural gradient'
shortHelpMsg['sg-lower'] = ' INPUT.cfacts OUTPUT.cfacts: convert from the 2nd-order format used for structural gradient to ordinary facts'
shortHelpMsg['sg-rel2ex'] = ' INPUT.cfacts [OUTPUT.examples]: convert from the 2nd-order format to a set of training/test examples'
shortHelpMsg['sg-grad2ppr'] = ' INPUT.gradient [OUTPUT.ppr]: convert features from gradient into rules'
shortHelpMsg['sg-train'] = ' INPUT1.examples INPUT2.cfacts: ...'

def doHelp(o):
   print 'ProPPR v2: commands are:'
   for com in sorted(shortHelpMsg.keys()):
      print '  proppr ' + com + shortHelpMsg[com]
   print 'other tips:'
   print '  (1) For all commands that invoke Java mains, options can be passed in by appending them,'
   print '      e.g. "proppr answer test.examples --prover tr"'
   print '  (2) For all commands that invoke Java mains, appending "--help" explains additional options'
   print '  (3) The environment variable PROPPR_JAVA_ARGS provides arguments to java itself,'
   print '      e.g. "export PROPPR_JAVA_ARGS=-Xmx32g" increases the heap size'
   print '  (4) Any global options precede the command, and the valid ones are:'
   print '      -Cfoo cd to directory \'foo\' before processing'
   print '      -n dry-run mode: print actions but don\'t perform them'
shortHelpMsg['help'] = ': this help message'

## helpers

def stemExt(fileName,expectedExtension):
   """Find the base file name, given an expected extension.  The first
   arg might or might not contain the extension, so given either
   fileName foo.ext or foo, this return the pair (foo,foo.ext).
   """
   if fileName.endswith(expectedExtension):
      return (fileName[:-len(expectedExtension)],fileName)
   else:
      if os.path.exists(fileName):
         stem = fileName.rfind('.')
         if stem<0: stem = len(fileName)
         return (fileName[:stem],fileName)
      return (fileName,fileName+expectedExtension)

def invokeMyself(o,*args):
   print 'invokeMyself',o,args
   procArgs = ['%s/scripts/proppr' % getRoot()]
   if 'out' in o and o['out']:
      procArgs.append('-C'+o['out'])
   if 'dryRun' in o and o['dryRun']:
      procArgs.append('-n')
   procArgs.extend(args)
   callProcess(o,procArgs)

def invokeMain(o,main,*mainProgArgs):
   """Invoke a main program, supplying options from the settings file
   and/or the command-line options."""
   root = getRoot()
   classPath = '.:%s/conf/:%s/bin:%s/lib/*' % (root,root,root)
   mainClass = 'edu.cmu.ml.proppr.%s' % main
   optArgs = []
   for (key,val) in loadOptionDict(o).items():
      optArgs.append(key)
      optArgs.append(val)
   callProcess(o,['java','-cp',classPath] + getJavaArgs()  + [mainClass] + list(mainProgArgs) + optArgs)

def invokeHelper(o,main,*mainProgArgs):
   """Invoke a python program from scripts/proppr-helpers, supplying
   options from the settings file and/or the command-line options.
   """
   root = getRoot()
   helperFile = '%s/scripts/proppr-helpers/%s' % (root,main)
   optArgs = []
   for (key,val) in loadOptionDict(o).items():
      optArgs.append(key)
      optArgs.append(val)
   callProcess(o,['python',helperFile] + list(mainProgArgs) + optArgs)

def callProcess(o,args,**kw):
   """Call a process, tracing the actual call."""
   if kw: logging.info('subprocess call options: '+ str(kw))
   logging.info('calling: ' + ' '.join(args))
   if o['dryRun']: return
   stat = subprocess.call(args,**kw)
   if stat:
      logging.info(('call failed (status %d): ' % stat) + ' '.join(args))
      sys.exit(stat) #propagate failure

def getRoot():
   """Get the root dir for the ProPPR codebase."""
   try:
      return os.environ['PROPPR']
   except IndexError:
      print "you must set the environment variable 'PROPPR' to the root of your source tree"
      sys.exit(-1)

def getJavaArgs():
   """Get any java arguments defined in the environment"""
   jargs = os.environ.get('PROPPR_JAVA_ARGS')
   return jargs.split() if jargs else []

def getOutputDirectory():
   """Get any output directory defined in the environment"""
   out = os.environ.get('PROPPR_OUTPUT')
   if out and not out.endswith("/"):
      out += "/"
   return out or ""

def getFile(name,o,quiet=False):
   """Return the file name, prepending the output directory defined by -C
   if necessary, and if quiet!=True, warning if the file does not
   exist.
   """
   test = name
   if os.path.exists(test): return test
   test = o['out']+name
   if os.path.exists(test): return test
   if quiet:return name
   print "no file %s in current directory" % name,
   if o['out']: print "or %s" % o['out']
   else: print ""

def makeOutput(filename,o):
   """Create an output filename with the requested filename, in the -C directory if requested."""
   if filename.startswith(o['out']): return filename
   return o['out']+filename

def getResourceFile(o,srcFile,dstFile):
   dst = makeOutput(dstFile,o)
   src = os.path.join( '%s/scripts/proppr-helpers/%s' % (getRoot(), srcFile))
   fp = open(dst,'w')
   for line in open(src):
      fp.write(line)
   logging.info('copied %s to %s' % (src,dst))

def getArg(i,defaultVal=None):
   """Get the i-th command line argument."""
   def safeDefault():
      if defaultVal: 
         return defaultVal
      else:
         logging.warn("expected at least %d command-line arguments - use 'proppr help' for help" % (i+1))
         sys.exit(-1)
   try:
      result = sys.argv[i+1]
      return result if not result.startswith("--") else safeDefault()
   except IndexError:      
      return safeDefault()

def getArgvOptions():
   """Find the command-line arguments starting with the first one that begins with --"""
   for i in range(len(sys.argv)):
      if sys.argv[i].startswith('--'):
         return sys.argv[i:]
   return []

def setArgvOption(n,val):
   for i in range(len(sys.argv)):
      if sys.argv[i].startswith('--'):
         sys.argv[i+n]=val
         return

def loadOptionDict(o):
   """Load options from proppr.settings, ie previously stored with 'proppr set',
   or from the command line."""
   opts = {}
   try:
      for line in open(getFile("proppr.settings",o,quiet=True),'r'):
         key,val = line.strip().split("\t")
         opts[key] = val
   except IOError:
      print 'warning: no options in proppr.settings yet'
   commandLineOpts = getArgvOptions()
   try:
      for i in range(0,len(commandLineOpts),2):
         opts[commandLineOpts[i]] = commandLineOpts[i+1]
   except IndexError:  #missing option value
      opts[commandLineOpts[i]] = '1'
   return opts

def saveOptionDict(opts,o):
   fp = open(o['out']+"proppr.settings",'w')
   for key,val in opts.items():
      fp.write(key + '\t' + val + '\n')
   fp.close()
   print 'saved',len(opts),'option(s) into proppr.settings'

## invoke main

if __name__ == "__main__":
   doMain()
